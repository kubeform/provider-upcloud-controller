/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type Server struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ServerSpec   `json:"spec,omitempty"`
	Status            ServerStatus `json:"status,omitempty"`
}

type ServerSpecLogin struct {
	// Indicates a password should be create to allow access
	// +optional
	CreatePassword *bool `json:"createPassword,omitempty" tf:"create_password"`
	// A list of ssh keys to access the server
	// +optional
	Keys []string `json:"keys,omitempty" tf:"keys"`
	// The delivery method for the serverâ€™s root password
	// +optional
	PasswordDelivery *string `json:"passwordDelivery,omitempty" tf:"password_delivery"`
	// Username to be create to access the server
	// +optional
	User *string `json:"user,omitempty" tf:"user"`
}

type ServerSpecNetworkInterface struct {
	// `true` if this interface should be used for network booting.
	// +optional
	Bootable *bool `json:"bootable,omitempty" tf:"bootable"`
	// The assigned IP address.
	// +optional
	IpAddress *string `json:"ipAddress,omitempty" tf:"ip_address"`
	// The IP address type of this interface (one of `IPv4` or `IPv6`).
	// +optional
	IpAddressFamily *string `json:"ipAddressFamily,omitempty" tf:"ip_address_family"`
	// `true` is a floating IP address is attached.
	// +optional
	IpAddressFloating *bool `json:"ipAddressFloating,omitempty" tf:"ip_address_floating"`
	// The assigned MAC address.
	// +optional
	MacAddress *string `json:"macAddress,omitempty" tf:"mac_address"`
	// The unique ID of a network to attach this network to.
	// +optional
	Network *string `json:"network,omitempty" tf:"network"`
	// `true` if source IP should be filtered.
	// +optional
	SourceIPFiltering *bool `json:"sourceIPFiltering,omitempty" tf:"source_ip_filtering"`
	// Network interface type. For private network interfaces, a network must be specified with an existing network id.
	Type *string `json:"type" tf:"type"`
}

type ServerSpecStorageDevices struct {
	// The device address the storage will be attached to. Specify only the bus name (ide/scsi/virtio) to auto-select next available address from that bus.
	// +optional
	Address *string `json:"address,omitempty" tf:"address"`
	// A valid storage UUID
	Storage *string `json:"storage" tf:"storage"`
	// The device type the storage will be attached as
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
}

type ServerSpecTemplateBackupRule struct {
	// The weekday when the backup is created
	Interval *string `json:"interval" tf:"interval"`
	// The number of days before a backup is automatically deleted
	Retention *int64 `json:"retention" tf:"retention"`
	// The time of day when the backup is created
	Time *string `json:"time" tf:"time"`
}

type ServerSpecTemplate struct {
	// The device address the storage will be attached to. Specify only the bus name (ide/scsi/virtio) to auto-select next available address from that bus.
	// +optional
	Address *string `json:"address,omitempty" tf:"address"`
	// The criteria to backup the storage
	// +optional
	BackupRule *ServerSpecTemplateBackupRule `json:"backupRule,omitempty" tf:"backup_rule"`
	// The unique identifier for the storage
	// +optional
	ID *string `json:"ID,omitempty" tf:"id"`
	// The size of the storage in gigabytes
	// +optional
	Size *int64 `json:"size,omitempty" tf:"size"`
	// A valid storage UUID or template name
	Storage *string `json:"storage" tf:"storage"`
	// The storage tier to use
	// +optional
	Tier *string `json:"tier,omitempty" tf:"tier"`
	// A short, informative description
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
}

type ServerSpec struct {
	State *ServerSpecResource `json:"state,omitempty" tf:"-"`

	Resource ServerSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`
}

type ServerSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// The number of CPU for the server
	// +optional
	Cpu *int64 `json:"cpu,omitempty" tf:"cpu"`
	// Are firewall rules active for the server
	// +optional
	Firewall *bool `json:"firewall,omitempty" tf:"firewall"`
	// Use this to start the VM on a specific host. Refers to value from host -attribute. Only available for private cloud hosts
	// +optional
	Host *int64 `json:"host,omitempty" tf:"host"`
	// A valid domain name
	Hostname *string `json:"hostname" tf:"hostname"`
	// Configure access credentials to the server
	// +optional
	Login *ServerSpecLogin `json:"login,omitempty" tf:"login"`
	// The size of memory for the server (in megabytes)
	// +optional
	Mem *int64 `json:"mem,omitempty" tf:"mem"`
	// Is the metadata service active for the server
	// +optional
	Metadata *bool `json:"metadata,omitempty" tf:"metadata"`
	// One or more blocks describing the network interfaces of the server.
	// +kubebuilder:validation:MinItems=1
	NetworkInterface []ServerSpecNetworkInterface `json:"networkInterface" tf:"network_interface"`
	// The pricing plan used for the server
	// +optional
	Plan *string `json:"plan,omitempty" tf:"plan"`
	// A list of storage devices associated with the server
	// +optional
	StorageDevices []ServerSpecStorageDevices `json:"storageDevices,omitempty" tf:"storage_devices"`
	// The server related tags
	// +optional
	Tags []string `json:"tags,omitempty" tf:"tags"`
	// Block describing the preconfigured operating system
	// +optional
	Template *ServerSpecTemplate `json:"template,omitempty" tf:"template"`
	// A short, informational description
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// Defines URL for a server setup script, or the script body itself
	// +optional
	UserData *string `json:"userData,omitempty" tf:"user_data"`
	// The zone in which the server will be hosted
	Zone *string `json:"zone" tf:"zone"`
}

type ServerStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// ServerList is a list of Servers
type ServerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of Server CRD objects
	Items []Server `json:"items,omitempty"`
}
