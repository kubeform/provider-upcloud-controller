/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type DatabasePostgresql struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DatabasePostgresqlSpec   `json:"spec,omitempty"`
	Status            DatabasePostgresqlStatus `json:"status,omitempty"`
}

type DatabasePostgresqlSpecComponents struct {
	// Type of the component
	// +optional
	Component *string `json:"component,omitempty" tf:"component"`
	// Hostname of the component
	// +optional
	Host *string `json:"host,omitempty" tf:"host"`
	// Port number of the component
	// +optional
	Port *int64 `json:"port,omitempty" tf:"port"`
	// Component network route type
	// +optional
	Route *string `json:"route,omitempty" tf:"route"`
	// Usage of the component
	// +optional
	Usage *string `json:"usage,omitempty" tf:"usage"`
}

type DatabasePostgresqlSpecNodeStates struct {
	// Name plus a node iteration
	// +optional
	Name *string `json:"name,omitempty" tf:"name"`
	// Role of the node
	// +optional
	Role *string `json:"role,omitempty" tf:"role"`
	// State of the node
	// +optional
	State *string `json:"state,omitempty" tf:"state"`
}

type DatabasePostgresqlSpecPropertiesMigration struct {
	// Database name for bootstrapping the initial connection
	// +optional
	Dbname *string `json:"dbname,omitempty" tf:"dbname"`
	// Hostname or IP address of the server where to migrate data from
	// +optional
	Host *string `json:"host,omitempty" tf:"host"`
	// Comma-separated list of databases, which should be ignored during migration (supported by MySQL only at the moment)
	// +optional
	IgnoreDbs *string `json:"ignoreDbs,omitempty" tf:"ignore_dbs"`
	// Password for authentication with the server where to migrate data from
	// +optional
	Password *string `json:"-" sensitive:"true" tf:"password"`
	// Port number of the server where to migrate data from
	// +optional
	Port *int64 `json:"port,omitempty" tf:"port"`
	// The server where to migrate data from is secured with SSL
	// +optional
	Ssl *bool `json:"ssl,omitempty" tf:"ssl"`
	// User name for authentication with the server where to migrate data from
	// +optional
	Username *string `json:"username,omitempty" tf:"username"`
}

type DatabasePostgresqlSpecPropertiesPgbouncer struct {
	// If the automatically created database pools have been unused this many seconds, they are freed. If 0 then timeout is disabled. [seconds]
	// +optional
	AutodbIdleTimeout *int64 `json:"autodbIdleTimeout,omitempty" tf:"autodb_idle_timeout"`
	// Do not allow more than this many server connections per database (regardless of user). Setting it to 0 means unlimited.
	// +optional
	AutodbMaxDbConnections *int64 `json:"autodbMaxDbConnections,omitempty" tf:"autodb_max_db_connections"`
	// PGBouncer pool mode
	// +optional
	AutodbPoolMode *string `json:"autodbPoolMode,omitempty" tf:"autodb_pool_mode"`
	// If non-zero then create automatically a pool of that size per user when a pool doesn't exist.
	// +optional
	AutodbPoolSize *int64 `json:"autodbPoolSize,omitempty" tf:"autodb_pool_size"`
	// List of parameters to ignore when given in startup packet
	// +optional
	// +kubebuilder:validation:MaxItems=32
	IgnoreStartupParameters []string `json:"ignoreStartupParameters,omitempty" tf:"ignore_startup_parameters"`
	// Add more server connections to pool if below this number. Improves behavior when usual load comes suddenly back after period of total inactivity. The value is effectively capped at the pool size.
	// +optional
	MinPoolSize *int64 `json:"minPoolSize,omitempty" tf:"min_pool_size"`
	// If a server connection has been idle more than this many seconds it will be dropped. If 0 then timeout is disabled. [seconds]
	// +optional
	ServerIdleTimeout *int64 `json:"serverIdleTimeout,omitempty" tf:"server_idle_timeout"`
	// The pooler will close an unused server connection that has been connected longer than this. [seconds]
	// +optional
	ServerLifetime *int64 `json:"serverLifetime,omitempty" tf:"server_lifetime"`
	// Run server_reset_query (DISCARD ALL) in all pooling modes
	// +optional
	ServerResetQueryAlways *bool `json:"serverResetQueryAlways,omitempty" tf:"server_reset_query_always"`
}

type DatabasePostgresqlSpecPropertiesPglookout struct {
	// max_failover_replication_time_lag
	// +optional
	MaxFailoverReplicationTimeLag *int64 `json:"maxFailoverReplicationTimeLag,omitempty" tf:"max_failover_replication_time_lag"`
}

type DatabasePostgresqlSpecPropertiesTimescaledb struct {
	// timescaledb.max_background_workers
	// +optional
	MaxBackgroundWorkers *int64 `json:"maxBackgroundWorkers,omitempty" tf:"max_background_workers"`
}

type DatabasePostgresqlSpecProperties struct {
	// Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
	// +optional
	AdminPassword *string `json:"-" sensitive:"true" tf:"admin_password"`
	// Custom username for admin user. This must be set only when a new service is being created.
	// +optional
	AdminUsername *string `json:"adminUsername,omitempty" tf:"admin_username"`
	// Automatic utility network IP Filter
	// +optional
	AutomaticUtilityNetworkIPFilter *bool `json:"automaticUtilityNetworkIPFilter,omitempty" tf:"automatic_utility_network_ip_filter"`
	// autovacuum_analyze_scale_factor
	// +optional
	AutovacuumAnalyzeScaleFactor *float64 `json:"autovacuumAnalyzeScaleFactor,omitempty" tf:"autovacuum_analyze_scale_factor"`
	// autovacuum_analyze_threshold
	// +optional
	AutovacuumAnalyzeThreshold *int64 `json:"autovacuumAnalyzeThreshold,omitempty" tf:"autovacuum_analyze_threshold"`
	// autovacuum_freeze_max_age
	// +optional
	AutovacuumFreezeMaxAge *int64 `json:"autovacuumFreezeMaxAge,omitempty" tf:"autovacuum_freeze_max_age"`
	// autovacuum_max_workers
	// +optional
	AutovacuumMaxWorkers *int64 `json:"autovacuumMaxWorkers,omitempty" tf:"autovacuum_max_workers"`
	// autovacuum_naptime
	// +optional
	AutovacuumNaptime *int64 `json:"autovacuumNaptime,omitempty" tf:"autovacuum_naptime"`
	// autovacuum_vacuum_cost_delay
	// +optional
	AutovacuumVacuumCostDelay *int64 `json:"autovacuumVacuumCostDelay,omitempty" tf:"autovacuum_vacuum_cost_delay"`
	// autovacuum_vacuum_cost_limit
	// +optional
	AutovacuumVacuumCostLimit *int64 `json:"autovacuumVacuumCostLimit,omitempty" tf:"autovacuum_vacuum_cost_limit"`
	// autovacuum_vacuum_scale_factor
	// +optional
	AutovacuumVacuumScaleFactor *float64 `json:"autovacuumVacuumScaleFactor,omitempty" tf:"autovacuum_vacuum_scale_factor"`
	// autovacuum_vacuum_threshold
	// +optional
	AutovacuumVacuumThreshold *int64 `json:"autovacuumVacuumThreshold,omitempty" tf:"autovacuum_vacuum_threshold"`
	// The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
	// +optional
	BackupHour *int64 `json:"backupHour,omitempty" tf:"backup_hour"`
	// The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
	// +optional
	BackupMinute *int64 `json:"backupMinute,omitempty" tf:"backup_minute"`
	// bgwriter_delay
	// +optional
	BgwriterDelay *int64 `json:"bgwriterDelay,omitempty" tf:"bgwriter_delay"`
	// bgwriter_flush_after
	// +optional
	BgwriterFlushAfter *int64 `json:"bgwriterFlushAfter,omitempty" tf:"bgwriter_flush_after"`
	// bgwriter_lru_maxpages
	// +optional
	BgwriterLruMaxpages *int64 `json:"bgwriterLruMaxpages,omitempty" tf:"bgwriter_lru_maxpages"`
	// bgwriter_lru_multiplier
	// +optional
	BgwriterLruMultiplier *float64 `json:"bgwriterLruMultiplier,omitempty" tf:"bgwriter_lru_multiplier"`
	// deadlock_timeout
	// +optional
	DeadlockTimeout *int64 `json:"deadlockTimeout,omitempty" tf:"deadlock_timeout"`
	// idle_in_transaction_session_timeout
	// +optional
	IdleInTransactionSessionTimeout *int64 `json:"idleInTransactionSessionTimeout,omitempty" tf:"idle_in_transaction_session_timeout"`
	// IP filter
	// +optional
	// +kubebuilder:validation:MaxItems=1024
	IpFilter []string `json:"ipFilter,omitempty" tf:"ip_filter"`
	// jit
	// +optional
	Jit *bool `json:"jit,omitempty" tf:"jit"`
	// log_autovacuum_min_duration
	// +optional
	LogAutovacuumMinDuration *int64 `json:"logAutovacuumMinDuration,omitempty" tf:"log_autovacuum_min_duration"`
	// log_error_verbosity
	// +optional
	LogErrorVerbosity *string `json:"logErrorVerbosity,omitempty" tf:"log_error_verbosity"`
	// log_line_prefix
	// +optional
	LogLinePrefix *string `json:"logLinePrefix,omitempty" tf:"log_line_prefix"`
	// log_min_duration_statement
	// +optional
	LogMinDurationStatement *int64 `json:"logMinDurationStatement,omitempty" tf:"log_min_duration_statement"`
	// max_files_per_process
	// +optional
	MaxFilesPerProcess *int64 `json:"maxFilesPerProcess,omitempty" tf:"max_files_per_process"`
	// max_locks_per_transaction
	// +optional
	MaxLocksPerTransaction *int64 `json:"maxLocksPerTransaction,omitempty" tf:"max_locks_per_transaction"`
	// max_logical_replication_workers
	// +optional
	MaxLogicalReplicationWorkers *int64 `json:"maxLogicalReplicationWorkers,omitempty" tf:"max_logical_replication_workers"`
	// max_parallel_workers
	// +optional
	MaxParallelWorkers *int64 `json:"maxParallelWorkers,omitempty" tf:"max_parallel_workers"`
	// max_parallel_workers_per_gather
	// +optional
	MaxParallelWorkersPerGather *int64 `json:"maxParallelWorkersPerGather,omitempty" tf:"max_parallel_workers_per_gather"`
	// max_pred_locks_per_transaction
	// +optional
	MaxPredLocksPerTransaction *int64 `json:"maxPredLocksPerTransaction,omitempty" tf:"max_pred_locks_per_transaction"`
	// max_prepared_transactions
	// +optional
	MaxPreparedTransactions *int64 `json:"maxPreparedTransactions,omitempty" tf:"max_prepared_transactions"`
	// max_replication_slots
	// +optional
	MaxReplicationSlots *int64 `json:"maxReplicationSlots,omitempty" tf:"max_replication_slots"`
	// max_stack_depth
	// +optional
	MaxStackDepth *int64 `json:"maxStackDepth,omitempty" tf:"max_stack_depth"`
	// max_standby_archive_delay
	// +optional
	MaxStandbyArchiveDelay *int64 `json:"maxStandbyArchiveDelay,omitempty" tf:"max_standby_archive_delay"`
	// max_standby_streaming_delay
	// +optional
	MaxStandbyStreamingDelay *int64 `json:"maxStandbyStreamingDelay,omitempty" tf:"max_standby_streaming_delay"`
	// max_wal_senders
	// +optional
	MaxWalSenders *int64 `json:"maxWalSenders,omitempty" tf:"max_wal_senders"`
	// max_worker_processes
	// +optional
	MaxWorkerProcesses *int64 `json:"maxWorkerProcesses,omitempty" tf:"max_worker_processes"`
	// Migrate data from existing server
	// +optional
	Migration *DatabasePostgresqlSpecPropertiesMigration `json:"migration,omitempty" tf:"migration"`
	// pg_partman_bgw.interval
	// +optional
	PgPartmanBgwInterval *int64 `json:"pgPartmanBgwInterval,omitempty" tf:"pg_partman_bgw_interval"`
	// pg_partman_bgw.role
	// +optional
	PgPartmanBgwRole *string `json:"pgPartmanBgwRole,omitempty" tf:"pg_partman_bgw_role"`
	// Should the service which is being forked be a read replica
	// +optional
	PgReadReplica *bool `json:"pgReadReplica,omitempty" tf:"pg_read_replica"`
	// Name of the PG Service from which to fork (deprecated, use service_to_fork_from). This has effect only when a new service is being created.
	// +optional
	PgServiceToForkFrom *string `json:"pgServiceToForkFrom,omitempty" tf:"pg_service_to_fork_from"`
	// pg_stat_statements.track
	// +optional
	PgStatStatementsTrack *string `json:"pgStatStatementsTrack,omitempty" tf:"pg_stat_statements_track"`
	// PGBouncer connection pooling settings
	// +optional
	Pgbouncer *DatabasePostgresqlSpecPropertiesPgbouncer `json:"pgbouncer,omitempty" tf:"pgbouncer"`
	// PGLookout settings
	// +optional
	Pglookout *DatabasePostgresqlSpecPropertiesPglookout `json:"pglookout,omitempty" tf:"pglookout"`
	// Public Access
	// +optional
	PublicAccess *bool `json:"publicAccess,omitempty" tf:"public_access"`
	// shared_buffers_percentage
	// +optional
	SharedBuffersPercentage *float64 `json:"sharedBuffersPercentage,omitempty" tf:"shared_buffers_percentage"`
	// Synchronous replication type. Note that the service plan also needs to support synchronous replication.
	// +optional
	SynchronousReplication *string `json:"synchronousReplication,omitempty" tf:"synchronous_replication"`
	// temp_file_limit
	// +optional
	TempFileLimit *int64 `json:"tempFileLimit,omitempty" tf:"temp_file_limit"`
	// TimescaleDB extension configuration values
	// +optional
	Timescaledb *DatabasePostgresqlSpecPropertiesTimescaledb `json:"timescaledb,omitempty" tf:"timescaledb"`
	// timezone
	// +optional
	Timezone *string `json:"timezone,omitempty" tf:"timezone"`
	// track_activity_query_size
	// +optional
	TrackActivityQuerySize *int64 `json:"trackActivityQuerySize,omitempty" tf:"track_activity_query_size"`
	// track_commit_timestamp
	// +optional
	TrackCommitTimestamp *string `json:"trackCommitTimestamp,omitempty" tf:"track_commit_timestamp"`
	// track_functions
	// +optional
	TrackFunctions *string `json:"trackFunctions,omitempty" tf:"track_functions"`
	// track_io_timing
	// +optional
	TrackIoTiming *string `json:"trackIoTiming,omitempty" tf:"track_io_timing"`
	// Variant of the PostgreSQL service, may affect the features that are exposed by default
	// +optional
	Variant *string `json:"variant,omitempty" tf:"variant"`
	// PostgreSQL major version
	// +optional
	Version *string `json:"version,omitempty" tf:"version"`
	// wal_sender_timeout
	// +optional
	WalSenderTimeout *int64 `json:"walSenderTimeout,omitempty" tf:"wal_sender_timeout"`
	// wal_writer_delay
	// +optional
	WalWriterDelay *int64 `json:"walWriterDelay,omitempty" tf:"wal_writer_delay"`
	// work_mem
	// +optional
	WorkMem *int64 `json:"workMem,omitempty" tf:"work_mem"`
}

type DatabasePostgresqlSpec struct {
	State *DatabasePostgresqlSpecResource `json:"state,omitempty" tf:"-"`

	Resource DatabasePostgresqlSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	SecretRef *core.LocalObjectReference `json:"secretRef,omitempty" tf:"-"`

	BackendRef *core.LocalObjectReference `json:"backendRef,omitempty" tf:"-"`
}

type DatabasePostgresqlSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// Service component information
	// +optional
	Components []DatabasePostgresqlSpecComponents `json:"components,omitempty" tf:"components"`
	// Maintenance window day of week. Lower case weekday name (monday, tuesday, ...)
	// +optional
	MaintenanceWindowDow *string `json:"maintenanceWindowDow,omitempty" tf:"maintenance_window_dow"`
	// Maintenance window UTC time in hh:mm:ss format
	// +optional
	MaintenanceWindowTime *string `json:"maintenanceWindowTime,omitempty" tf:"maintenance_window_time"`
	// Name of the service. The name is used as a prefix for the logical hostname. Must be unique within an account
	Name *string `json:"name" tf:"name"`
	// Information about nodes providing the managed service
	// +optional
	NodeStates []DatabasePostgresqlSpecNodeStates `json:"nodeStates,omitempty" tf:"node_states"`
	// Service plan to use. This determines how much resources the instance will have
	Plan *string `json:"plan" tf:"plan"`
	// The administrative power state of the service
	// +optional
	Powered *bool `json:"powered,omitempty" tf:"powered"`
	// Primary database name
	// +optional
	PrimaryDatabase *string `json:"primaryDatabase,omitempty" tf:"primary_database"`
	// Database Engine properties for PostgreSQL
	// +optional
	Properties *DatabasePostgresqlSpecProperties `json:"properties,omitempty" tf:"properties"`
	// Hostname to the service instance
	// +optional
	ServiceHost *string `json:"serviceHost,omitempty" tf:"service_host"`
	// Primary username's password to the service instance
	// +optional
	ServicePassword *string `json:"-" sensitive:"true" tf:"service_password"`
	// Port to the service instance
	// +optional
	ServicePort *string `json:"servicePort,omitempty" tf:"service_port"`
	// URI to the service instance
	// +optional
	ServiceURI *string `json:"-" sensitive:"true" tf:"service_uri"`
	// Primary username to the service instance
	// +optional
	ServiceUsername *string `json:"serviceUsername,omitempty" tf:"service_username"`
	// SSL Connection Mode for PostgreSQL
	// +optional
	Sslmode *string `json:"sslmode,omitempty" tf:"sslmode"`
	// State of the service
	// +optional
	State *string `json:"state,omitempty" tf:"state"`
	// Title of a managed database instance
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// Type of the service
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Zone where the instance resides
	Zone *string `json:"zone" tf:"zone"`
}

type DatabasePostgresqlStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// DatabasePostgresqlList is a list of DatabasePostgresqls
type DatabasePostgresqlList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of DatabasePostgresql CRD objects
	Items []DatabasePostgresql `json:"items,omitempty"`
}
